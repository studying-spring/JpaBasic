# 프록시
- em.find() vs em.getReference()
- 전자, 실제 엔티티 객체 조회, 후자는 가짜 엔티티 객체 조회
- 그러니깐, getUserName과 같이 find를 하면(사용되면) 그 때 쿼리가 나간다.
- 하이버네이트가 만든 가짜 클래스(프록시 클래스)
![img_4.png](img_4.png)
- 영속성 컨텍스트한테 초기화를 요청하면, 실제 엔티티를 생성해준다.
## 프록시 특징
- 프록시 객체는 사용될 때 한번만 초기화
- 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 게 아님 !! <<-- 중요, 교체되는 것이 아니라 타겟이 바뀜
- == 비교 대신에 instance of를 사용, 원본 엔티티를 상속받기 때문
- 중요한 것: em.find해도 프록시가 나올 수 있는데, 나오든 말든 문제가 없게 개발을 하는 것.
- jpa는 어떻게 == 를 뱉는다. 그래서 엔티티가 있으면 em.getReference를 해도 엔티티를 뱉는다. 반대도 마찬가지
- 그러나 준영속 상태일 때, 프록시를 초기화하면 문제 발생
```java
Member refMember = em.getReference(Member.class, member1.getId());
em.detach(refMember); or close(); or clear();
refMember.getUsername();
```
- 위 처럼되면 프록시를 초기화 할 수 없다.
## 즉시 로딩과 지연 로딩
### 지연로딩
- (fetch = FetchType.LAZY)
- 지연로딩을 걸어주면, getTeam을 하지 않으면 team은 프록시로 넘어온다.
- 즉, team을 실제로 사용할 때 쿼리가 나간다.
### 즉시로딩
- (fetch = FetchType.EAGER)
- 얘는 그냥 다 가져온다.
- 실무에서는 즉시로딩 쓰면 안된다.
  - 예상치 못한 SQL이 나간다.
  - 뭐.. 아무튼 쓰지마요
- fetch join으로 대부분 사용한다. 다 LAZY로가고..
- ManyToOne, OneToOne은 기본이 즉시 로딩이다,, 다 LAZY로 바꿔야한다.

## 영속성 전이: CASCADE
- 위의 지연, 즉시 로딩과 관계가 없다.
- 그냥 부모 엔티티 저장할 때, 자식 엔티티도 저장하고 싶을 때.
- 즉 특정 엔티티를 영속 상태로 만들 때, 연관된 엔티티도 영속 상태로 만들고 싶을 때 사용
- 게시판, 첨부파일 같은 경우에 쓸 수 있다. 그런데 파일을 여러 군데에서 관리를 하면 쓰면 안된다.
- 즉 부모만 자식을 관리할 때, 소유주가 하나일 때 cascade를 사용한다.

## 고아 객체
- 부모 엔티티와 연관관계가 끊어진 자식엔티티를 자동으로 삭제
- 참조하는 곳이 하나일 때 사용해야한다. 게시판의 첨부파일
- CascadeType.Remove처럼 동작.. 음 그냥 CASCADE 쓰면 될 듯?
- 언제 쓰냐면 스스로 생명주기를 관리하는 놈은 em.persist, em.remove로 제거하고, 부모 엔티티를 통해서 자식의 생명주기를 관리할 수 있다.
