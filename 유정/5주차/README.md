# 다양한 연관관계 매핑

## 다대일 [N:1]

- 외래 키가 있는 쪽이 연관관계의 주인
- 다쪽에 외래키

## 일대다 [1:N] (사용하지 말자)

일대다 단방향(실무에서는 거의 사용하지 않는 모델)

- 일이 연관관계 주인
- 그래서 멤버와 팀에서 팀에 있는 멤버리스트를 수정하면 멤버 테이블에 있는 팀아이디가 수정
- 객체와 테이블의 차이(객체 측에서는 일이 주인인데 테이블에서는 다 쪽에 외래키가 있으므로 객체 측에서 보았을 때 반대편 테이블의 외래 키를 관리하는 특이한 구조를 가지게 됨)
- Update 쿼리가 추가로 실행이 됨

→ 일대다 단방향 매핑보다는 **다대일 양방향 매핑**

일대다 양방향(좀 억지스러움)

```
// 읽기 전용
@ManyToOne
@JoinColumn(name = "TEAM_ID", insertable = false, updatable = false)
private Team team;
```

## 일대일 [1:1]

- 외래 키는 어디에나 넣어도 됨 (비즈니스 로직에 따라서 정하기)
- 일대일이기 때문에 외래 키에 유니크 조건을 걸기

일대일 : 주 테이블에 외래 키 단방향

일대일 : 주 테이블에 외래 키 양방향

- 외래 키가 있는 곳이 주인
- 반대편은 mappedBy 적용
1. JPA 매핑 편리
2. 값이 없으면 외래 키에 null 허용

일대일 : 대상 테이블에 외래 키 단방향 (JPA 지원X)

일대일 : 대상 테이블에 외래 키 양방향 == 일대일 : 주 테이블에 외래키 양방향

1. 주:대상 - 일대일에서 일대다로 관계로 변경할 때 테이블 구조 유지
2. 양방향으로 만들어야 함
3. 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨

## 다대다 [N:M] (실무에서 쓰지 말기~)

- 관계형 데이터베이스는 다대다 관계를 표현할 수 없음
- 연결 테이블을 추가해서 대대일, 일대다로 풀어내야 함
- 객체는 다대다 관계가 가능

한계점

- 편리해 보이지만 단순히 연결만 하고 끝나지 않음 (분명히 필요한 추가적인 내용이 있음)

극복

- 중간 테이블을 엔티티로 승격시키기!